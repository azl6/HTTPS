# Symmetric and asymmetric algorithms

AES: Simetric, like AES256 used for SSE-S3. **Same key to encrypt and decrypt**.

RSA: Asymmetric, like SSH keys generated by `ssg-keygen -t rsa`. **Different keys to encrypt and decrypt**.

# Encryption algorithms

![image](https://user-images.githubusercontent.com/80921933/221655495-b6c42783-cc87-4d36-b963-f4abee26c20f.png)

# Hashing algorithms

![image](https://user-images.githubusercontent.com/80921933/221645440-40d1c495-c327-4a01-9cff-3541512cce80.png)

# Gerando hash com o SHA-256

Usei a flag `-a 256` para especificar o SHA-256. Podemos alterar essa flag para selecionar o algorítmo adequado.

```bash
echo "Hello world!" > file.txt
shasum -a 256 file.txt 
0ba904eae8773b70c75333db4de2f3ac45a8ad4ddba1b242f0b3cfc199391dd8  file.txt ####### Hash gerado pelo algorítmo
``` 

# Using OpenSSL

The following command generates a RSA key

```bash
openssl genrsa
```

To encrypt it, we can use the flag `-aes256`

```bash
openssl genrsa -aes256
```

To save the private-key to a file, we use the `-out` flag

```bash
openssl genrsa -aes256 -out myoutfile.txt
```

When we generate a RSA key with openssl, the public-key comes "mixed" with it. To extract the public-key, we use the following command:

```bash
openssl rsa -in <RSAOUTFILEFROMLASTCOMMAND> -outform PEM -pubout -out <PUBLICKEYNAME>
```

We can also generate different sizes of keys, like

```bash
openssl genrsa 4096
```

# How does the browser trust certain certificates

The OS comes "packed" with the root certificates installed. 

That means, if the certificate provided by the website matches the OS-downloaded root-certificate, a HTTPS connection will be successfully established

This is possible because intermediate-certificates are signed by the root-certificates, and the intermediate-certificates sign the end-user certificate

![Screenshot from 2023-02-27 17-06-08](https://user-images.githubusercontent.com/80921933/221672411-8c601bea-5835-42f3-ad64-564edfc6e039.png)

![sgds](https://user-images.githubusercontent.com/80921933/221672955-fd9f4d73-134b-4aa4-97f1-1b58272ea315.png)

# Certificates trust chain 

![image](https://user-images.githubusercontent.com/80921933/221681490-9b1f5dd0-be16-420b-893f-97b5ebd7ec05.png)

# Certificate domain scopes

![image](https://user-images.githubusercontent.com/80921933/221687673-1f2bd140-2fd9-4977-83f6-e28518ec7f81.png)

# Establishing a TLS connection

Cyper suites are information about the algorithms that will be used in that particular session, like AES-128 for encryption and SHA-256 for hashing

![image](https://user-images.githubusercontent.com/80921933/221692429-884c8abf-3abd-4731-8a0e-76712e1259d3.png)

![image](https://user-images.githubusercontent.com/80921933/221692051-f46c8315-f7c9-49ae-a121-ee725f317388.png)

# Installing certificates on nginx

To install nginx on Amazon Linux 2 machines (source: https://stackoverflow.com/questions/57784287/how-to-install-nginx-on-aws-ec2-linux-2):

```bash
sudo amazon-linux-extras enable nginx1
sudo yum clean metadata
sudo yum -y install nginx
sudo service nginx start
```

Now, to create a server-block for our domain, follow the **Step 5** of the following tutorial: https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-20-04

Explanation of some aspects of the configuration:

This configuration consists in creating the `/var/www/your_domain/html/index.html` structure, changing `my_domain` for our created domain, aka alexthedeveloper.com.br

```bash
server {
        listen 80; ########## Listening port for IPV4
        listen [::]:80; ##### Listening port for IPV6

        root /var/www/alexthedeveloper.com.br/html; ### Place the client will be redirected to when entering the address in the server_name field
        index index.html index.htm index.nginx-debian.html;

        server_name alexthedeveloper.com.br www.alexthedeveloper.com.br; ### Adresses that will redirect to the root file

        location / {
                try_files $uri $uri/ =404;
        }
}
```


